#!/usr/bin/env ruby
require 'mongo'
require 'optparse'

module WorkflowServer
  class BackbeatMongo

    attr_accessor :client, :db, :init_script, :pid_file, :src_db_path, :dest_db_path

    def initialize(options = {})
      self.client = ::Mongo::MongoClient.new(options[:host], options[:port])
      self.db = client['admin']
      self.init_script = "/usr/local/etc/init.d/mongodb#{options[:mongo_id]}"
      self.pid_file = "/var/groupon/mongo/mongodb#{options[:mongo_id]}/mongod.lock"
      self.src_db_path = "/var/groupon/mongo/mongodb#{options[:mongo_id]}/"
      self.dest_db_path = "/var/groupon/mongo_backup/mongodb#{options[:mongo_id]}"
    end

    def perform
      raise "Not eligible to perform backups on this mongo node" unless eligible?
      shutdown
      backup
      start
    end

    private

    def eligible?
      my_id && (secondary_ids.sort.last == my_id) # use the last secondary for this operation
    end

    def shutdown
      if running?
        system(init_script, "stop")
        done = false
        20.times do
          done = true unless running?
          break if done
          sleep 1
        end
        raise "unable to shutdown mongo for backup" unless done
      end
    end

    def backup
      puts "Starting rsync at #{Time.now}"
      system("rsync","-av","--stats","--delete",src_db_path,dest_db_path)
      puts "Finished rsync at #{Time.now}"
    end

    def start
      unless running?
        system(init_script,"start")
        done = false
        20.times do
          done = true if running?
          break if done
          sleep 1
        end
        raise "unable to startup mongo after backup" unless done
      end
    end

    def my_id
      unless @my_id
        me = status['members'].find {|member| member["self"] == true }
        @my_id = me ? me["_id"] : nil
      end
      @my_id
    end

    def secondary_ids
      @secondary_ids ||= status['members'].find_all {|member| member["stateStr"] != "PRIMARY"}.map {|secondary| secondary["_id"]}
    end

    def status
      @status ||= run(:replSetGetStatus)
    end

    def running?
      signal(0)
    end

    def signal(signal)
      begin
        process_id = File.read(pid_file).chomp
        process_id.nil? ? false : Process.kill(signal, process_id.to_i) && true
      rescue Errno::ESRCH
        File.delete(pid_file) rescue nil
        false
      rescue Errno::ENOENT
        # bad file, nothing is running
        false
      end
    end

    private

    def run(command)
      db.command({command => 1})
    end
  end
end

def parse_args(args)
  options = {
    host: 'localhost',
    port: 27017,
    mongo_id: 1
  }

  opts = OptionParser.new do |opts|
    opts.banner = "Usage: #{File.basename($0)} -h host -p port -i mongo_id"
    opts.on("-h host", "--host host", String, "mongo host") { |h| options[:host] = h}
    opts.on("-p port", "--port port", String, "mongo port") {|p| options[:port] = p}
    opts.on("-i id", "--mongoid id", String, "mongo instance id") {|i| options[:mongo_id] = i}
    opts.on_tail("-h", "--help", "show this message") do
      puts opts
      exit
    end
  end
  opts.parse(args)
  WorkflowServer::BackbeatMongo.new(options).perform
end

parse_args(ARGV)
