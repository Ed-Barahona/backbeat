#!/usr/bin/env ruby

# simple script to start one process

require_relative '../app'

def start(pidfile)
  fork do
    hostname = `hostname`.chomp
    File.open(pidfile, File::CREAT|File::TRUNC|File::RDWR) do |f|
      f.write(Process.pid)
    end

    mongo_path = File.expand_path(File.join(WorkflowServer::Config.root, "config", "mongoid.yml"))
    Mongoid.load!(mongo_path, WorkflowServer::Config.environment)

    Delayed::Worker.logger = WorkflowServer::DelayedJobLogger
    Delayed::Worker.lifecycle.before(:perform) { |*args| WorkflowServer::Logger.tid(:set) }
    Delayed::Worker.lifecycle.after(:perform) { |*args| WorkflowServer::Logger.tid(:clear) }
    Delayed::Worker.new.start
  end
end

def stop(pidfile)
  signal("TERM", pidfile)
end

def restart(pidfile)
  stop(pidfile)
  killed_it = false
  10.times do
    unless running?(pidfile)
      killed_it = true
      break
    end
    sleep 1
  end
  if killed_it == false
    raise "unable to kill #{File.read(pidfile).chomp rescue pidfile}. giving up." 
  end
  start(pidfile)
end

def running?(pidfile)
  signal(0, pidfile)
end

# Signal a process.
def signal(signal, pidfile)
  process_id = pid = File.read(pidfile).chomp
  begin
    process_id.nil? ? false : Process.kill(signal, process_id.to_i) && true
  rescue Errno::ESRCH
    File.delete(pidfile)
    false
  end
end

begin
  raise "No arguments" if ARGV.size == 0
  raise "Too many arguments" if ARGV.size > 2
  command = case
    when ARGV[0] =~ /^\s*start\s*/ then start(ARGV[1])
    when ARGV[0] =~ /^\s*stop\s*/ then stop(ARGV[1])
    when ARGV[0] =~ /^\s*restart\s*/ then restart(ARGV[1])
    when ARGV[0] =~ /^\s*status\s*/ then running?(ARGV[1])
    else raise "No method found for #{ARGV[0]}"
  end
  exit(command ? 0 : 1)
rescue => e
  puts e
  exit(1)
end